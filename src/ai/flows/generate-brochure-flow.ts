
// This file is intentionally left empty or commented out as AI features
// were requested to be removed for stabilization.

// 'use server';
/**
 * @fileOverview AI flow for generating brochure content sections.
 * This flow is currently disabled.
 *
 * - generateBrochureContent - A function to generate content for specific brochure sections.
 * - GenerateBrochureInput - The input type for the generateBrochureContent function.
 * - BrochureContentOutput - The return type for the generateBrochureContent function.
 */

/*
import { ai } from '@/ai/genkit';
import { z } from 'genkit';
import {
    BrochureDataSchema, // Assuming this contains the full structure
    type BrochureData,
} from '@/components/brochure/data-schema'; // Adjusted import

// Define which sections can be generated by AI (subset of BrochureData keys)
export const BrochureAIDataSectionsEnum = z.enum([
    "intro", 
    "developer", 
    "location", 
    "connectivity",
    "amenitiesIntro",
    "amenitiesList", // For descriptions if needed, not individual items
    "amenitiesGrid", // For title/disclaimer if needed
    "specs",         // For descriptions if needed
    "masterPlan",
    "floorPlans"     // For overall title/disclaimer, not individual plans
]);
export type BrochureAIDataSection = z.infer<typeof BrochureAIDataSectionsEnum>;


const GenerateBrochureInputSchema = z.object({
  existingData: BrochureDataSchema.describe("The current brochure data, which may be partially filled by the user."),
  sectionToGenerate: BrochureAIDataSectionsEnum.describe("The specific section of the brochure to generate content for."),
  promptHint: z.string().optional().describe("Optional user-provided hint or keywords to guide content generation for the specific section (e.g., 'modern and luxurious living for families')."),
  projectName: z.string().describe("The core project name to be used throughout the brochure content generation for context.")
});

export type GenerateBrochureInput = z.infer<typeof GenerateBrochureInputSchema>;

// Output schema should be a partial of BrochureData, containing only the fields relevant to the section
// This is complex to define dynamically with Zod based on sectionToGenerate.
// For simplicity, the AI will be instructed to return only relevant fields,
// and we'll merge them. The prompt will define the expected output structure.
const BrochureContentOutputSchema = BrochureDataSchema.partial().describe("The generated content for the specified brochure section.");
export type BrochureContentOutput = z.infer<typeof BrochureContentOutputSchema>;


export async function generateBrochureContent(
  input: GenerateBrochureInput
): Promise<BrochureContentOutput> {
  console.log("Calling AI to generate content for section:", input.sectionToGenerate);
  return generateContentFlow(input);
}

const generateContentPrompt = ai.definePrompt({
  name: 'generateBrochureSectionPrompt',
  input: { schema: GenerateBrochureInputSchema },
  output: { schema: BrochureContentOutputSchema }, // AI will attempt to fill this structure
  prompt: `
You are a professional real estate copywriter tasked with generating content for a specific section of a property brochure.
Your goal is to expand on the provided existing data for the project named "{{projectName}}" and generate compelling, professional, and relevant content for the section: "{{sectionToGenerate}}".

**Key Instructions:**

1.  **Focus:** Only generate content for the fields relevant to the "{{sectionToGenerate}}" section. Do NOT invent data for other sections.
2.  **Context is King:** Use the 'existingData' (provided as a JSON object below) as the primary source of truth and context. Your generated content must be consistent with and expand upon this data.
3.  **Project Name:** Always refer to the project as "{{projectName}}".
4.  **Elaboration, Not Invention:** If 'existingData' for the target section is sparse or contains only default placeholders (like "Default text..."), elaborate thoughtfully. If specific details are missing (e.g., exact number of amenities if not provided), write in a way that is appealing yet general, or suggest placeholders like "[Number] amenities". Do NOT invent specific numbers, names, or features not hinted at in 'existingData' or 'promptHint'.
5.  **Placeholder Handling:** If a text field in 'existingData' for the target section contains only generic placeholder content (e.g., "Describe the project...", "Default text..."), treat it as if it's empty and generate fresh, relevant content based on 'projectName', other 'existingData' context, and the 'promptHint'.
6.  **Adherence to Hints:** If a 'promptHint' is provided ("{{#if promptHint}}{{promptHint}}{{else}}None{{/if}}"), use it to guide the tone, style, and focus of the generated content for the "{{sectionToGenerate}}" section.
7.  **Professional Tone:** Maintain a professional, persuasive, and high-quality writing style suitable for a real estate brochure.
8.  **Conciseness:** Be descriptive but avoid unnecessary fluff. Brochure text needs to be impactful.
9.  **JSON Output Structure:**
    *   Your output MUST be a valid JSON object.
    *   The JSON object should ONLY contain the keys and values for the fields relevant to the "{{sectionToGenerate}}" section. For example, if sectionToGenerate is "intro", only include keys like "introTitle", "introParagraph1", etc.
    *   Refer to the output schema description for the expected fields for each section.
    *   If a field within the target section is not applicable or no content can be plausibly generated based on input, omit the key or return an empty string for it.

**Existing Brochure Data (JSON):**
\`\`\`json
{{{JSONstringify existingData}}}
\`\`\`

**Target Section for Content Generation:** {{sectionToGenerate}}
**Project Name:** {{projectName}}
{{#if promptHint}}**User Hint:** {{promptHint}}{{/if}}

Generate the content for the "{{sectionToGenerate}}" section now.
Remember to output ONLY a valid JSON object containing the fields relevant to the "{{sectionToGenerate}}".
`,
  },
  {
      helpers: {
          JSONstringify: (context) => JSON.stringify(context),
      }
  }
);


const generateContentFlow = ai.defineFlow(
  {
    name: 'generateBrochureContentFlow',
    inputSchema: GenerateBrochureInputSchema,
    outputSchema: BrochureContentOutputSchema,
  },
  async (input: GenerateBrochureInput): Promise<BrochureContentOutput> => {
    console.log("Executing generateContentFlow with input:", JSON.stringify(input, null, 2));

    // Create a payload that matches the prompt's input schema expectations
    const promptInputPayload = {
        existingData: input.existingData,
        sectionToGenerate: input.sectionToGenerate,
        promptHint: input.promptHint,
        projectName: input.projectName
    };
    
    const {output: rawAiOutput} = await generateContentPrompt(promptInputPayload);
    
    if (!rawAiOutput) {
      console.error("AI failed to generate brochure content. No output received. Input to AI:", JSON.stringify(promptInputPayload, null, 2));
      throw new Error("AI failed to generate brochure content. No output received.");
    }

    console.log("Raw AI Output for section " + input.sectionToGenerate + ":", JSON.stringify(rawAiOutput, null, 2));

    // Validate the AI's output against the partial schema
    // The AI should only return fields for the section it was asked to generate.
    try {
        const validatedSectionOutput = BrochureContentOutputSchema.parse(rawAiOutput);
        console.log("Validated & Parsed AI Output for section " + input.sectionToGenerate + ":", JSON.stringify(validatedSectionOutput, null, 2));
        return validatedSectionOutput;
    } catch (error) {
        console.error("AI output validation failed for section " + input.sectionToGenerate + ". Error:", error instanceof z.ZodError ? error.errors : error);
        console.error("Problematic AI Output:", JSON.stringify(rawAiOutput, null, 2));
        
        // Attempt to merge valid parts of AI output with existing data for the section
        // This is a fallback strategy if full validation fails
        let partiallyMergedOutput = {};
        if (typeof rawAiOutput === 'object' && rawAiOutput !== null) {
            for (const key in rawAiOutput) {
                if (Object.prototype.hasOwnProperty.call(rawAiOutput, key) && key in BrochureDataSchema.shape) {
                     // Only take keys that are valid for BrochureData
                    (partiallyMergedOutput as any)[key] = (rawAiOutput as any)[key];
                }
            }
        }
        
        // Try to validate the partially merged output
        try {
            const finalOutput = BrochureContentOutputSchema.parse(partiallyMergedOutput);
            console.warn("AI output partially recovered and validated for section " + input.sectionToGenerate + ":", JSON.stringify(finalOutput, null, 2));
            return finalOutput;
        } catch (validationError) {
            console.error("Final validation of partially recovered AI output also failed for section " + input.sectionToGenerate + ". Error:", validationError instanceof z.ZodError ? validationError.errors : validationError);
            if (validationError instanceof z.ZodError) {
                console.error("Details of ZodError on merged output:", JSON.stringify(validationError.flatten(), null, 2));
            } else {
                console.error("Validation error on mergedOutput was not a ZodError:", validationError);
            }
            throw new Error("AI output validation failed and could not be automatically corrected. Check logs for details on AI output and original data validation.");
        }
    }
  }
);
*/
